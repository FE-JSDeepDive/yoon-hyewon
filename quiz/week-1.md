# 기술 면접 정리 (4장,5장,6장)

## 4장

### 1. 블록 스코프와 함수 스코프의 차이점에 대해 설명해주세요

- 스코프란?: 함수 내 변수에 접근할 수 있는 범위
  <br/>
- 블록 스코프는 블록 {}이 생성될 때마다 새로운 스코프 형성
- let, const
  <br/>
- 함수 스코프는 함수가 생성될 때마다 새로운 스코프 형성
- var
- 실행 컨텍스트가 메모리에 저장되어 함수가 종료되어도 제거되지 않는 전역 변수가 생성됨

### 2. 전역 변수 사용을 최소화해야하는 이유는 무엇일까요?

- 충돌 가능성: 전역 변수는 어디에서나 접근 가능하므로 다른 라이브러리나 코드와 충돌함. 변수명 중복으로 인해 의도치 않은 동작 유발 가능성 높음.
- 스코프 오염: 전역 변수를 사용하면, 다른 함수나 블록 내에서도 동일한 변수 이름을 사용하고 변경할 수 있음. 이로 인해 변수의 예기치 않은 변경이 발생할 수 있음.
- 유지보수 어려움: 전역 변수를 사용하면 코드 가독성이 떨어짐.
- 성능 저하: 전역 변수를 사용하면 해당 변수에 접근하기 위해 스코프 체인을 거쳐야 함.
- 메모리 낭비: 자바스크립트 엔진은 실행 컨텍스트를 콜스택에 저장하므로 전역 변수의 생명 주기가 스크립트 종료될 때까지 유지되어 불필요한 메모리 낭비함.
  <br/>

+) 콜스택이란?
<br/>

- 여러 함수를 호출하는 스크립트에서 해당 위치를 추적하는 인터프리터를 위한 매커니즘
- 현재 어떤 함수가 동작하고 있는지, 그 함수 내에서 어떤 함수가 동작하는 지, 다음에 어떤 함수가 호출되어야하는지 제어함.

### 3. 기본형 데이터와 참조형 데이터의 차이점은 무엇일까요?

1. 기본형(Primitive type)

- `string` `number` `bigint` `boolean` `undefined` `symbol` `null`
- 값 자체를 저장하고, 변수에 직접 할당됨
- Stack 메모리에 저장됨
- 변수를 복사할 때 값이 복사됨 (새로운 메모리 공간 생성됨)
- 변경 불가능한 값으로 메모리 영역에서 변경이 불가능함 (불변성)
  <br/>

2. 참조형(Reference Type)

- `Object` `Array` `Function` `Date` `RegExp`
- 값이 아니라 메모리 주소(참조값)를 저장함
- Heap 메모리에 저장됨
- 변수를 복사하면 참조(주소)가 복사됨 (같은 객체를 가리킴)
- 가변성을 가짐 -> 참조된 객체 수정 가능

### 4. setTimeout에서 var를 사용하면 발생할 수 있는 문제는 무엇인가요? (for 루프 내 setTimeout)

- 클로저 문제 발생 가능성
- 비동기 관련 문제 가능성

### 5. const로 선언한 객체에 setTimeout 내부에서 값을 변경할 수 있을까요?

- 객체 자체는 재할당할 수 없음
- const는 변수 자체를 변경할 수 없지만, 참조형 데이터(객체, 배열)의 내부 속성은 변경 가능
- 객체가 메모리에서 가리키는 주소(참조값)는 변경할 수 없지만, 객체 내부의 프로퍼티는 변경할 수 있음.

  <br/>
+) Property(JavaScript)
  <br/>

- property는 해당 object의 특징입니다. property는 보통 데이터 구조와 연관된 속성을 나타냅니다. property에는 2가지 종류가 있습니다.
- 인스턴스 프로퍼티(Instance property)는 특정 object 인스턴스의 특정한 데이터를 가지고 있습니다.
- 정적 프로퍼티(Static Property)는 모든 object 인스턴스들에게 공유되는 데이터를 가지고 있습니다.

### 6. JS에서 변수를 선언하지 않고 사용할 수 있나요?

- 선언하지 않으면, var가 자동으로 선언됨

### 7. window 객체에 변수 선언이 미치는 영향은 무엇인가요?

- window 객체는 브라우저 환경에서 전역 객체 역할을 함.
- 전역 번위에서 변수 선언 시 자동으로 window 객체의 속성이 될 수 있음.

1. var로 선언한 변수 → window 객체에 등록됨
2. let과 const로 선언한 변수 → window 객체에 등록되지 않음
3. 선언 없이 변수를 사용하면 → window 객체에 자동 등록됨 (비권장)

## 6장

### 1. JavaScript에서 null과 undefined의 차이는 무엇인가요?

- null : "값이 없음"을 개발자가 의도적으로 설정
- undefined: "값이 할당되지 않음" ,변수가 선언되었지만 값이 할당되지 않았을 때 자동으로 부여되는 값 (변수가 선언되었지만 값이 없음)

```js
let a; // undefined (값이 할당되지 않음)
console.log(a); // undefined

let b = null; // 명시적으로 "값 없음"을 표현
console.log(b); // null
```

### 2. null을 숫자로 변환하면 어떤 값이 나오나요?

- 숫자 0으로 변환됨
  +) undefined는 NaN으로 변환되며, null == 0은 false지만 Number(null) === 0은 true가 됩니다.

## 7장

### 1. null == undefined는 true인데, null === undefined는 false인 이유는?

1. ==(느슨한 비교): 타입 변환 후 값을 비교

- JavaScript의 동등 연산자(==) 규칙에 따르면, null과 undefined는 서로 같음으로 취급됩니다.
- null과 undefined가 모두 “값이 없음”을 표현하는 특수한 값이기 때문입니다.

2. ===(엄격한 비교): 타입 변환 없이 값을 비교 // 타입 변환 없이 비교하며, 두 값이 데이터 타입까지 일치해야 true를 반환합니다.

- null의 타입: "object"
- undefined의 타입: "undefined"
- 서로 타입이 다르므로 엄격한 비교에서는 false가 반환됩니다.

  ```js
  console.log(0 == "0"); // true (문자열 "0"이 숫자 0으로 변환됨)
  console.log(0 === "0"); // false (타입이 다름)
  console.log(null == undefined); // true (둘 다 값이 비어있다고 간주)
  console.log(null === undefined); // false (타입이 다름)
  ```

### 2. "0" == 0의 결과는 무엇이며, "0" === 0은 왜 다르게 평가되나요?

- "0" == 0에서는 JavaScript의 느슨한 비교(==)가 문자열을 숫자로 변환하여 비교하기 때문에 true가 됩니다. 반면 === 연산자는 타입 변환 없이 비교하기 때문에, "0"은 string이고 0은 number여서 false가 됩니다.

### 3. i++와 ++i의 차이는 무엇인가요?

- i++: 현재 값을 반환 후 증가
- ++i: 증가 후 새로운 값 반환
